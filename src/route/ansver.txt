Завдання 1: Бонус створюється і обчислюється у методі `Purchase.updateBonusBalance`. Щоб здійснити округлення до найближчого більшого цілого числа, використовуйте функцію `Math.ceil`. Оновіть рядок:

```javascript
const amount = this.calcBonusAmount(price)
```

на:

```javascript
const amount = Math.ceil(this.calcBonusAmount(price))
```

Завдання 2: ID товару створюється у конструкторі класу `Product` за допомогою статичного приватного поля `#count`. Оскільки воно є статичним, воно існує на рівні класу, а не окремого екземпляру, і кожен раз збільшується при створенні нового товару.

```javascript
this.id = ++Product.#count
```

Рішення тут вже вірне, і ID товару буде збільшуватися при кожному створенні нового товару. Воно вже є унікальним та зростає автоматично.

Для замовлень та покупців, аналогічний підхід застосований у класі `Purchase`, де `#count` також є статичним приватним полем, яке інкрементується при створенні нового замовлення.

Завдання 3: Щоб перейти зі сторінки `purchase-list` на сторінку `purchase-edit`, потрібно додати HTML-елемент посилання (орієнтовно `<a href="/purchase-edit?id=ID_ЗАМОВЛЕННЯ">Редагувати</a>`) на кожному рядку з переліком замовлень. У вашому коді місце для посилання вже наявне


### Завдання 1: Унікальні зростаючі ID

Щоб мати зростаючий та унікальний `id` для кожного товару та покупки, вам потрібно змінити спосіб надання ID. Це можна зробити, створивши окремий лічільник для товарів і замовлень, який не скидається та не залежить від кількості реальних товарів чи покупців у списку.

```javascript
class UniqueIdGenerator {
  static productCounter = 0;
  static purchaseCounter = 0;
  
  static getNextProductId() {
    return ++this.productCounter;
  }
  
  static getNextPurchaseId() {
    return ++this.purchaseCounter;
  }
}

// Приклад використання в класі Product
this.id = UniqueIdGenerator.getNextProductId();

// Приклад використання в класі Purchase
this.id = UniqueIdGenerator.getNextPurchaseId();
```

### Завдання 2: Відображення категорій товару у консолі

Причиною того, що категорії товару не відображаються, може бути те, як ви спробували їх залогувати. Якщо в коді ви викликаєте `console.log()` для виводу категорій і вони не відображаються, переконайтеся, що ви передаєте вірний об'єкт в `console.log()` та що ви використовуєте це на сервері, де консоль дійсно доступна.

Якщо про категорії ідеться в самому шаблоні (наприклад, використовуючи `{{categories}}` в рендерингу шаблонів), то треба переконатися, що ви правильно передаєте дані категорій у об'єкті для рендерингу. Наприклад:

```javascript
// Припустимо data - це ваш об'єкт, що містить інформацію про товар
res.render('purchase-product', {
  ...
  categories: data.product.categories // або product.categories залежно від контексту
  ...
});
```

У вашому шаблоні, вам потрібно буде ітерувати через категорії та відображати потрібні дані. Якщо ви користуєтесь engines шаблонів, таких як EJS або Handlebars, цей процес може виглядати приблизно так:

```ejs
<% product.categories.forEach(function(category) { %>
  <div><%= category.text %></div>
<% }); %>
```

або для Handlebars:

```handlebars
{{#each product.categories}}
  <div>{{this.text}}</div>
{{/each}}
```

Забезпечте правильний доступ до цих даних і правильно налаштований рендеринг у шаблонах.  

### Завдання 1: Унікальні та Неповторні ID

Якщо унікальний лічильник `UniqueIdGenerator` не допомагає в генерації унікального `id`, здається, ви не інтегрували його правильно або ви все ще використовуєте старий метод присвоєння `id`. У вашому прикладі використання унікального лічильника, ви не показали, як саме ви використовуєте цей лічильник в конструкторі `Product` та в конструкторі `Purchase`. Вам потрібно замінити рядки, де інкрементується `Product.#count` та `Purchase.#count`, з новими методами `UniqueIdGenerator.getNextProductId()` та `UniqueIdGenerator.getNextPurchaseId()`, відповідно. Ось як вам слід змінити конструктори:

```javascript
class Product {
  // Конструктор та інші методи
  
  constructor(img, title, description, category, price, amount = 0) {
    this.id = UniqueIdGenerator.getNextProductId();
    // інший код...
  }

  // ...решта класу...
}

class Purchase {
  // Конструктор та інші методи
  
  constructor(data, product) {
    this.id = UniqueIdGenerator.getNextPurchaseId();
    // інший код...
  }

  // ...решта класу...
}
```

### Завдання 2: Відображення Категорій Товару

Коли ви бачите `[Object]` виведене console.log, це означає, що ці об'єкти містять вкладені дані, які не відображаються повністю. Ви можете відформатувати вихід для відображення вмісту цих об'єктів. Для відображення в консолі використовуйте `JSON.stringify` для перетворення об'єкта у рядок у форматі JSON, що забезпечує можливість бачити вкладені властивості, наприклад:

```javascript
console.log(JSON.stringify(product, null, 2));
```

Другий параметр `null` та третій параметр `2` забезпечують красиве форматування з відступами, що робить результат більш читабельним.

Якщо система поводження даними не може безпосередньо відображати об'єкти (`[Object]`), то можна вручну ітерувати через масив категорій і логувати або відображати їх властивості одну за одною, наприклад:

```javascript
product.category.forEach(cat => {
  console.log(`Категорія ID: ${cat.id}, Текст: ${cat.text}`);
});
```

Це слід зробити там, де ви хочете вивести категорії до реального виводу, наприклад, перед рендерингом інформації про товар на сторінці або в консолі сервера.  